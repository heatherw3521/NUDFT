function [Xu, Xv, VA, VB] = ek_sylv_blkdiag(A, B, u, v, k, tol, debug)
%EK_SYLV_BLKDIAG Approximate the solution of a Sylvester equation A X + X B' = U*V' in the krylov space
%            generated by principal diagonal blocks of dimension n/2 (rounded if needed) of A and B.
%
% [XU,XV] = EK_SYLV_BLKDIAG(A, B, U, V, K) approximates the solution of the
%     Sylvester equation in the factored form XU * XV'.
%
% [XU, VA] = EK_SYLV_BLKDIAG(A, B, U, V, K, TOL, DEBUG) also returns the bases VA
%     and VB, and the optional parameters TOL and DEBUG control the
%     stopping criterion and the debugging during the iteration.
%
% The tolerance TOL can also be specified as a function TOL(R, N) that
% takes as input the residual norm and the norm of the solution (R and N,
% respectively), and returns true if the solution can be accepted.

if ~exist('debug', 'var')
    debug = false;
end

% Check if the rktoolbox is in the path
if ~exist('rat_krylov', 'file')
    error('rktoolbox not found. Did you forget to add it to the path?');
end
n = size(A,1);
m = ceil(n/2);
if ~isstruct(A)	% Per il momento  gestito solo il caso in cui A e B sono matrici sparse (possibile inghippo)
    AA = ek_struct(blkdiag(A(1:m,1:m), A(m+1:end,m+1:end)));
    % AA = ek_struct(A);
    dA = [sparse(m,m), A(1:m,m+1:end); A(m+1:end,1:m), sparse(n-m,n-m)];
else
    AA = A;
end

if ~isstruct(B)
    BB = ek_struct(blkdiag(B(1:m,1:m)',B(m+1:end,m+1:end)'));
    % BB = ek_struct(B');
    dB = [sparse(m,m), B(m+1:end,1:m)'; B(1:m,m+1:end)', sparse(n-m,n-m)];
else
    BB = B';
end

nrmA = AA.nrm;
nrmB = BB.nrm;

% Find out the maximum bandwidth of the off-diagonal blocks
bw = bandwidth(A);

% And insert appropriate generators into the basis
z = zeros(n, 2*bw);
z(m-bw+1:m+bw,:) = eye(2 * bw);

u2 = [ u, z ];
v2 = [ v, z ];

% Recompress the basis
[qu2, ru2] = qr(u2, 0);
[qv2, rv2] = qr(v2, 0);

[u2, s2, v2] = svd(ru2 * rv2');
rk = sum(diag(s2) > s2(1,1) * eps);
u2 = qu2 * u2(:,1:rk) * sqrt(s2(1:rk,1:rk));
v2 = qv2 * v2(:,1:rk) * sqrt(s2(1:rk,1:rk));

% Start with the initial basis
[VA, KA, HA] = rat_krylov(AA, u2, inf);
[VB, KB, HB] = rat_krylov(BB, v2, inf);

% Dimension of the space
sa = size(u2, 2);
sb = size(v2, 2);

bsa = sa;
bsb = sb;

Cprojected = ( VA(:,1:size(u2,2))' * u ) * ( v' * VB(:,1:size(v2,2)) );

if ~exist('tol', 'var')
    tol = 1e-8;
end

% tol can be function tol(r, n) that is given the residual and the norm, or
% a scalar. In the latter case, we turn it into a function
if isfloat(tol)
    tol_eps = tol;
    tol = @(r, n) r < tol_eps * n;
end

it=1;
while max(sa-2*bsa, sb-2*bsb) < k
    [VA, KA, HA] = rat_krylov(AA, VA, KA, HA, [0 inf]);
    [VB, KB, HB] = rat_krylov(BB, VB, KB, HB, [0 inf]);
    
    sa = size(VA, 2);
    sb = size(VB, 2);
    
    % Compute the solution and residual of the projected Lyapunov equation
    As = HA(1:end-bsa,:) / KA(1:end-bsa,:) + VA(:, 1: size(HA,1)-bsa)' * dA * VA(:, 1: size(KA,2));
    Bs = HB(1:end-bsa,:) / KB(1:end-bsb,:) + VB(:, 1: size(HB,1)-bsa)' * dB * VB(:, 1: size(KB,2));
    
    Cs = zeros(size(As, 1), size(Bs, 1));
    Cs(1:size(u2,2), 1:size(v2,2)) = Cprojected;
    
    [Y, res] = lyap_galerkin(As, Bs, Cs, 2*bsa, 2*bsb);
    
    % You might want to enable this for debugging purposes
    if debug
        fprintf('%d Residue: %e\n', it, res / norm(Y));
    end
    
    if tol(res, norm(Y)) % res < norm(Y) * tol
        break
    end
    it=it+1;
end

% it

% fprintf('lyap its = %d, nrmA = %e\n', it, nrmA)
[UU,SS,VV] = svd(Y);

% rk = sum(diag(SS) > SS(1,1) * tol / max(nrmA, nrmB));
rk = sum(arrayfun(@(s) tol(s, SS(1,1) \ max(nrmA, nrmB)), diag(SS)) == false);

Xu = VA(:,1:size(Y,1)) * UU(:,1:rk) * sqrt(SS(1:rk,1:rk));
Xv = VB(:,1:size(Y,2)) * VV(:,1:rk) * sqrt(SS(1:rk,1:rk));

end

